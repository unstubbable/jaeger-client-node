{"version":3,"sources":["../../../test/samplers/adapt_sampler.js"],"names":["adapter","describe","it","assert","isNull","adaptSampler","fake","apiVersion","s1","GuaranteedThroughputSampler","s2","deepEqual","_delegate","ConstSampler","equal","toString","throws","adaptSamplerOrThrow","Error","_called","isSampled","operationName","outTags","span","onCreateSpan","onSetOperationName","onSetTag","callback","sinon","spy","close","isTrue","called","c","LegacySamplerV1Base"],"mappings":"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","file":"adapt_sampler.js","sourcesContent":["// @flow\n// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport { assert } from 'chai';\nimport sinon from 'sinon';\n// Import Tracer here to work around a weird bug that causes the error like this:\n//     TypeError: Super expression must either be null or a function, not undefined\n//         at _inherits (.../jaeger-client-node/src/samplers/const_sampler.js:27:113)\n// The error seems to be related to a recursive import _adapt_sampler -> Span -> Tracer -> _adapt_sampler.\nimport Tracer from '../../src/tracer';\nimport * as adapter from '../../src/samplers/_adapt_sampler';\nimport LegacySamplerV1Base from '../../src/samplers/_adapt_sampler';\nimport ConstSampler from '../../src/samplers/const_sampler';\nimport GuaranteedThroughputSampler from '../../src/samplers/guaranteed_throughput_sampler';\n\ndescribe('adaptSampler', () => {\n  it('should return null for null argument', () => {\n    assert.isNull(adapter.adaptSampler(null));\n  });\n  it('should return null for malformed argument', () => {\n    assert.isNull(adapter.adaptSampler({ fake: 'fake', apiVersion: 'v1' }));\n  });\n  it('should return wrapper for v1 sampler', () => {\n    let s1 = new GuaranteedThroughputSampler(0, 1.0);\n    let s2: any = adapter.adaptSampler(s1);\n    assert.deepEqual(s1, s2._delegate);\n  });\n  it('should return v2 sampler as is', () => {\n    let s1 = new ConstSampler(true);\n    assert.equal(s1, adapter.adaptSampler(s1));\n  });\n  it('should delegate toString', () => {\n    let s1 = new GuaranteedThroughputSampler(0, 1.0);\n    let s2: any = adapter.adaptSampler(s1);\n    assert.equal(s1.toString(), s2.toString());\n  });\n});\n\ndescribe('adaptSamplerOrThrow', () => {\n  it('should throw on unrecognized sampler', () => {\n    assert.throws(() => adapter.adaptSamplerOrThrow(null), Error, 'Unrecognized sampler: null');\n  });\n});\n\ndescribe('LegacySamplerV1Adapter', () => {\n  it('should delegate sampling methods to isSampled', () => {\n    let s1: any = new ConstSampler(true);\n    s1.apiVersion = ''; // break V2 compatibility\n    let s2: any = adapter.adaptSampler(s1);\n    assert.deepEqual(s1, s2._delegate);\n    s1._called = 0;\n    s1.isSampled = (operationName: string, outTags: {}) => {\n      s1._called++;\n    };\n    let span: Span = {};\n    s2.onCreateSpan(span);\n    s2.onSetOperationName(span, 'op1');\n    s2.onSetTag(span, 'pi', 3.1415); // this one is no-op, so does not increment the counter\n    s2.isSampled('op1', {});\n    assert.equal(3, s1._called);\n  });\n  it('should delegate close()', () => {\n    let s1: any = new ConstSampler(true);\n    s1.apiVersion = ''; // break V2 compatibility\n    let s2: any = adapter.adaptSampler(s1);\n    assert.deepEqual(s1, s2._delegate);\n    let span: Span = {};\n    let callback = sinon.spy();\n    s2.close(callback);\n    assert.isTrue(callback.called);\n  });\n});\n\ndescribe('LegacySamplerV1Base', () => {\n  it('should throw in isSampled', () => {\n    let c = new LegacySamplerV1Base('test');\n    assert.throws(() => c.isSampled('op1', {}), Error, 'Subclass must override isSampled()');\n  });\n});\n"]}